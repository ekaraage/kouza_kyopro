<!-- omit in toc -->
# CCS 競プロ講座'21 第2回
<!-- omit in toc -->

## 目次

## 2.1 計算量
競技プログラミングでは、コードの実行が制限時間内(多くは2秒)で終了しなければいけません。コードの実行時間を大雑把に見積もる手段として、計算量の解析が行われます。(厳密な言及ではないことを先に断っておきます。)  
[できるだけ嘘を書かずに計算量やオーダーの説明をしようとした記事](https://rsk0315.hatenablog.com/entry/2021/10/13/235627#fn-f262e163)を読みましょう。
入力$n$が十分大きくなった時、処理を行う回数を$n$の関数で上から/下から抑えましょう。というのがオーダーのやりたいことです。詳しく知りたい方はちゃんと読んでください。
$\Omicron(f(n))$と書いてある代わりに$\theta(f(n))$と書いてある方が多くの場合で正確だね～みたいな話です。
だいたいオーダーの中身、すなわち$f(n)$の値が$10^7～10^8$くらいだったら通ります。

## 2.2 累積和
変化のない区間に対する、逆元の存在する演算を高速に行うためのデータ構造です。

単位元とは:ある演算(ここでは\*とします)を考えます。集合から要素を1つ取ってきて、$x$とします。どんな$x$に対しても$x*e=e*x=x$となる(つまり、変化させない)$e$が存在するとき、この$e$を単位元と呼びます。足し算だと0で、掛け算だと1です。

逆元とは:ある$x$に対して、$x*a=a*x=e$なる$a$が存在するとき、この$a$を逆元と呼びます。足し算だと$-x$で、掛け算だと逆数です。

ある配列$a$に対して、
$$ s[i+1]=s[i]+a[i] $$

なる配列を考えます。この配列$s$を累積和と呼びます。ただし、$s[0]=0$。

このような定義によると、$s[i]:=[0,i)$の和となって、区間和$a[l] + \cdots + a[r-1]=s[r]-s[l]$としていつでも高速に求められます。
区間和の計算は1回ごとに$\theta(N)$かかる($N$は配列$a$のサイズ)が、累積和では構築$\theta(N)$、計算$\theta(1)$なので、いっぱい計算をしたい場合に便利です。

詳しくは[累積和を何も考えずに書けるようにする!](https://qiita.com/drken/items/56a6b68edef8fc605821)を参照。

## 2.3 応用例
和の代わりにxorを載せたり、積を載せたりできます。また、逆元が存在しませんが、maxやmin、gcdを載せることもあります。逆元が存在しないときは両側から累積するといいことがあります。
## 2.4 練習問題
[Score Sum Queries](https://atcoder.jp/contests/typical90/tasks/typical90_j)
[総和](https://atcoder.jp/contests/abc037/tasks/abc037_c)
[Attention](https://atcoder.jp/contests/abc098/tasks/arc098_a)
[Exception Handling](https://atcoder.jp/contests/abc134/tasks/abc134_c)
ヒント:逆元が存在しないので……？(累積和じゃなくても解けます。)
[GCD on Blackboard](https://atcoder.jp/contests/abc125/tasks/abc125_c)

